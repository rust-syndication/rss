<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A low level encoding-agnostic XML event reader."><title>Reader in quick_xml::reader - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="quick_xml" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.1 (eb26296b5 2023-08-03)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../quick_xml/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../quick_xml/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Reader</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.buffer_position">buffer_position</a></li><li><a href="#method.check_comments">check_comments</a></li><li><a href="#method.check_end_names">check_end_names</a></li><li><a href="#method.decoder">decoder</a></li><li><a href="#method.expand_empty_elements">expand_empty_elements</a></li><li><a href="#method.from_file">from_file</a></li><li><a href="#method.from_reader">from_reader</a></li><li><a href="#method.from_str">from_str</a></li><li><a href="#method.get_mut">get_mut</a></li><li><a href="#method.get_ref">get_ref</a></li><li><a href="#method.into_inner">into_inner</a></li><li><a href="#method.read_event">read_event</a></li><li><a href="#method.read_event_into">read_event_into</a></li><li><a href="#method.read_text">read_text</a></li><li><a href="#method.read_to_end">read_to_end</a></li><li><a href="#method.read_to_end_into">read_to_end_into</a></li><li><a href="#method.trim_markup_names_in_closing_tags">trim_markup_names_in_closing_tags</a></li><li><a href="#method.trim_text">trim_text</a></li><li><a href="#method.trim_text_end">trim_text_end</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Clone-for-Reader%3CR%3E">Clone</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-Reader%3CR%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Reader%3CR%3E">Send</a></li><li><a href="#impl-Sync-for-Reader%3CR%3E">Sync</a></li><li><a href="#impl-Unpin-for-Reader%3CR%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Reader%3CR%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-Reader%3CR%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-Reader%3CR%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-Reader%3CR%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-Reader%3CR%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-Reader%3CR%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-Reader%3CR%3E">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-Reader%3CR%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-Reader%3CR%3E">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In quick_xml::reader</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../index.html">quick_xml</a>::<wbr><a href="index.html">reader</a>::<wbr><a class="struct" href="#">Reader</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/quick_xml/reader/mod.rs.html#523-528">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Reader&lt;R&gt; { /* private fields */ }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A low level encoding-agnostic XML event reader.</p>
<p>Consumes bytes and streams XML <a href="../events/enum.Event.html" title="enum quick_xml::events::Event"><code>Event</code></a>s.</p>
<p>This reader does not manage namespace declarations and not able to resolve
prefixes. If you want these features, use the <a href="struct.NsReader.html" title="struct quick_xml::reader::NsReader"><code>NsReader</code></a>.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quick_xml::events::Event;
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span>xml = <span class="string">r#&quot;&lt;tag1 att1 = &quot;test&quot;&gt;
                &lt;tag2&gt;&lt;!--Test comment--&gt;Test&lt;/tag2&gt;
                &lt;tag2&gt;Test 2&lt;/tag2&gt;
             &lt;/tag1&gt;&quot;#</span>;
<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_str(xml);
reader.trim_text(<span class="bool-val">true</span>);

<span class="kw">let </span><span class="kw-2">mut </span>count = <span class="number">0</span>;
<span class="kw">let </span><span class="kw-2">mut </span>txt = Vec::new();
<span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();

<span class="comment">// The `Reader` does not implement `Iterator` because it outputs borrowed data (`Cow`s)
</span><span class="kw">loop </span>{
    <span class="comment">// NOTE: this is the generic case when we don&#39;t know about the input BufRead.
    // when the input is a &amp;str or a &amp;[u8], we don&#39;t actually need to use another
    // buffer, we could directly call `reader.read_event()`
    </span><span class="kw">match </span>reader.read_event_into(<span class="kw-2">&amp;mut </span>buf) {
        <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">panic!</span>(<span class="string">&quot;Error at position {}: {:?}&quot;</span>, reader.buffer_position(), e),
        <span class="comment">// exits the loop when reaching end of file
        </span><span class="prelude-val">Ok</span>(Event::Eof) =&gt; <span class="kw">break</span>,

        <span class="prelude-val">Ok</span>(Event::Start(e)) =&gt; {
            <span class="kw">match </span>e.name().as_ref() {
                <span class="string">b&quot;tag1&quot; </span>=&gt; <span class="macro">println!</span>(<span class="string">&quot;attributes values: {:?}&quot;</span>,
                                    e.attributes().map(|a| a.unwrap().value)
                                    .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;()),
                <span class="string">b&quot;tag2&quot; </span>=&gt; count += <span class="number">1</span>,
                <span class="kw">_ </span>=&gt; (),
            }
        }
        <span class="prelude-val">Ok</span>(Event::Text(e)) =&gt; txt.push(e.unescape().unwrap().into_owned()),

        <span class="comment">// There are several other `Event`s we do not consider here
        </span><span class="kw">_ </span>=&gt; (),
    }
    <span class="comment">// if we don&#39;t keep a borrow elsewhere, we can clear the buffer to keep memory usage low
    </span>buf.clear();
}</code></pre></div>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Reader%3CR%3E" class="impl"><a class="srclink rightside" href="../../src/quick_xml/reader/buffered_reader.rs.html#258-400">source</a><a href="#impl-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R: <a class="trait" href="https://doc.rust-lang.org/1.71.1/std/io/trait.BufRead.html" title="trait std::io::BufRead">BufRead</a>&gt; <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;</h3></section></summary><div class="docblock"><p>This is an implementation for reading from a <a href="https://doc.rust-lang.org/1.71.1/std/io/trait.BufRead.html" title="trait std::io::BufRead"><code>BufRead</code></a> as underlying byte stream.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.read_event_into" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/buffered_reader.rs.html#303-305">source</a><h4 class="code-header">pub fn <a href="#method.read_event_into" class="fn">read_event_into</a>&lt;'b&gt;(&amp;mut self, buf: &amp;'b mut <a class="struct" href="https://doc.rust-lang.org/1.71.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.u8.html">u8</a>&gt;) -&gt; <a class="type" href="../type.Result.html" title="type quick_xml::Result">Result</a>&lt;<a class="enum" href="../events/enum.Event.html" title="enum quick_xml::events::Event">Event</a>&lt;'b&gt;&gt;</h4></section></summary><div class="docblock"><p>Reads the next <code>Event</code>.</p>
<p>This is the main entry point for reading XML <code>Event</code>s.</p>
<p><code>Event</code>s borrow <code>buf</code> and can be converted to own their data if needed (uses <code>Cow</code>
internally).</p>
<p>Having the possibility to control the internal buffers gives you some additional benefits
such as:</p>
<ul>
<li>Reduce the number of allocations by reusing the same buffer. For constrained systems,
you can call <code>buf.clear()</code> once you are done with processing the event (typically at the
end of your loop).</li>
<li>Reserve the buffer length if you know the file size (using <code>Vec::with_capacity</code>).</li>
</ul>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quick_xml::events::Event;
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span>xml = <span class="string">r#&quot;&lt;tag1 att1 = &quot;test&quot;&gt;
                &lt;tag2&gt;&lt;!--Test comment--&gt;Test&lt;/tag2&gt;
                &lt;tag2&gt;Test 2&lt;/tag2&gt;
             &lt;/tag1&gt;&quot;#</span>;
<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_str(xml);
reader.trim_text(<span class="bool-val">true</span>);
<span class="kw">let </span><span class="kw-2">mut </span>count = <span class="number">0</span>;
<span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();
<span class="kw">let </span><span class="kw-2">mut </span>txt = Vec::new();
<span class="kw">loop </span>{
    <span class="kw">match </span>reader.read_event_into(<span class="kw-2">&amp;mut </span>buf) {
        <span class="prelude-val">Ok</span>(Event::Start(<span class="kw">_</span>)) =&gt; count += <span class="number">1</span>,
        <span class="prelude-val">Ok</span>(Event::Text(e)) =&gt; txt.push(e.unescape().unwrap().into_owned()),
        <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">panic!</span>(<span class="string">&quot;Error at position {}: {:?}&quot;</span>, reader.buffer_position(), e),
        <span class="prelude-val">Ok</span>(Event::Eof) =&gt; <span class="kw">break</span>,
        <span class="kw">_ </span>=&gt; (),
    }
    buf.clear();
}
<span class="macro">assert_eq!</span>(count, <span class="number">3</span>);
<span class="macro">assert_eq!</span>(txt, <span class="macro">vec!</span>[<span class="string">&quot;Test&quot;</span>.to_string(), <span class="string">&quot;Test 2&quot;</span>.to_string()]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_to_end_into" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/buffered_reader.rs.html#395-399">source</a><h4 class="code-header">pub fn <a href="#method.read_to_end_into" class="fn">read_to_end_into</a>(
    &amp;mut self,
    end: <a class="struct" href="../name/struct.QName.html" title="struct quick_xml::name::QName">QName</a>&lt;'_&gt;,
    buf: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.71.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.u8.html">u8</a>&gt;
) -&gt; <a class="type" href="../type.Result.html" title="type quick_xml::Result">Result</a>&lt;<a class="type" href="type.Span.html" title="type quick_xml::reader::Span">Span</a>&gt;</h4></section></summary><div class="docblock"><p>Reads until end element is found using provided buffer as intermediate
storage for events content. This function is supposed to be called after
you already read a <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event.</p>
<p>Returns a span that cover content between <code>&gt;</code> of an opening tag and <code>&lt;</code> of
a closing tag or an empty slice, if <a href="struct.Reader.html#method.expand_empty_elements" title="method quick_xml::reader::Reader::expand_empty_elements"><code>expand_empty_elements</code></a> is set and
this method was called after reading expanded <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event.</p>
<p>Manages nested cases where parent and child elements have the <em>literally</em>
same name.</p>
<p>If corresponding <a href="../events/enum.Event.html#variant.End" title="variant quick_xml::events::Event::End"><code>End</code></a> event will not be found, the <a href="../enum.Error.html#variant.UnexpectedEof" title="variant quick_xml::Error::UnexpectedEof"><code>Error::UnexpectedEof</code></a>
will be returned. In particularly, that error will be returned if you call
this method without consuming the corresponding <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event first.</p>
<p>If your reader created from a string slice or byte array slice, it is
better to use <a href="struct.Reader.html#method.read_to_end" title="method quick_xml::reader::Reader::read_to_end"><code>read_to_end()</code></a> method, because it will not copy bytes
into intermediate buffer.</p>
<p>The provided <code>buf</code> buffer will be filled only by one event content at time.
Before reading of each event the buffer will be cleared. If you know an
appropriate size of each event, you can preallocate the buffer to reduce
number of reallocations.</p>
<p>The <code>end</code> parameter should contain name of the end element <em>in the reader
encoding</em>. It is good practice to always get that parameter using
<a href="../events/struct.BytesStart.html#method.to_end" title="method quick_xml::events::BytesStart::to_end"><code>BytesStart::to_end()</code></a> method.</p>
<p>The correctness of the skipped events does not checked, if you disabled
the <a href="struct.Reader.html#method.check_end_names" title="method quick_xml::reader::Reader::check_end_names"><code>check_end_names</code></a> option.</p>
<h5 id="namespaces"><a href="#namespaces">Namespaces</a></h5>
<p>While the <code>Reader</code> does not support namespace resolution, namespaces
does not change the algorithm for comparing names. Although the names
<code>a:name</code> and <code>b:name</code> where both prefixes <code>a</code> and <code>b</code> resolves to the
same namespace, are semantically equivalent, <code>&lt;/b:name&gt;</code> cannot close
<code>&lt;a:name&gt;</code>, because according to <a href="https://www.w3.org/TR/xml11/#dt-etag">the specification</a></p>
<blockquote>
<p>The end of every element that begins with a <strong>start-tag</strong> MUST be marked
by an <strong>end-tag</strong> containing a name that echoes the element’s type as
given in the <strong>start-tag</strong></p>
</blockquote>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<p>This example shows, how you can skip XML content after you read the
start event.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quick_xml::events::{BytesStart, Event};
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_str(<span class="string">r#&quot;
    &lt;outer&gt;
        &lt;inner&gt;
            &lt;inner&gt;&lt;/inner&gt;
            &lt;inner/&gt;
            &lt;outer&gt;&lt;/outer&gt;
            &lt;outer/&gt;
        &lt;/inner&gt;
    &lt;/outer&gt;
&quot;#</span>);
reader.trim_text(<span class="bool-val">true</span>);
<span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();

<span class="kw">let </span>start = BytesStart::new(<span class="string">&quot;outer&quot;</span>);
<span class="kw">let </span>end   = start.to_end().into_owned();

<span class="comment">// First, we read a start event...
</span><span class="macro">assert_eq!</span>(reader.read_event_into(<span class="kw-2">&amp;mut </span>buf).unwrap(), Event::Start(start));

<span class="comment">// ...then, we could skip all events to the corresponding end event.
// This call will correctly handle nested &lt;outer&gt; elements.
// Note, however, that this method does not handle namespaces.
</span>reader.read_to_end_into(end.name(), <span class="kw-2">&amp;mut </span>buf).unwrap();

<span class="comment">// At the end we should get an Eof event, because we ate the whole XML
</span><span class="macro">assert_eq!</span>(reader.read_event_into(<span class="kw-2">&amp;mut </span>buf).unwrap(), Event::Eof);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Reader%3CBufReader%3CFile%3E%3E" class="impl"><a class="srclink rightside" href="../../src/quick_xml/reader/buffered_reader.rs.html#402-409">source</a><a href="#impl-Reader%3CBufReader%3CFile%3E%3E" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.71.1/std/io/buffered/bufreader/struct.BufReader.html" title="struct std::io::buffered::bufreader::BufReader">BufReader</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.71.1/std/fs/struct.File.html" title="struct std::fs::File">File</a>&gt;&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_file" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/buffered_reader.rs.html#404-408">source</a><h4 class="code-header">pub fn <a href="#method.from_file" class="fn">from_file</a>&lt;P: <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.71.1/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(path: P) -&gt; <a class="type" href="../type.Result.html" title="type quick_xml::Result">Result</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Creates an XML reader from a file path.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Reader%3C%26'a+%5Bu8%5D%3E" class="impl"><a class="srclink rightside" href="../../src/quick_xml/reader/slice_reader.rs.html#22-234">source</a><a href="#impl-Reader%3C%26'a+%5Bu8%5D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.u8.html">u8</a>]&gt;</h3></section></summary><div class="docblock"><p>This is an implementation for reading from a <code>&amp;[u8]</code> as underlying byte stream.
This implementation supports not using an intermediate buffer as the byte slice
itself can be used to borrow from.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_str" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/slice_reader.rs.html#25-36">source</a><h4 class="code-header">pub fn <a href="#method.from_str" class="fn">from_str</a>(s: &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.str.html">str</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates an XML reader from a string slice.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_event" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/slice_reader.rs.html#73-75">source</a><h4 class="code-header">pub fn <a href="#method.read_event" class="fn">read_event</a>(&amp;mut self) -&gt; <a class="type" href="../type.Result.html" title="type quick_xml::Result">Result</a>&lt;<a class="enum" href="../events/enum.Event.html" title="enum quick_xml::events::Event">Event</a>&lt;'a&gt;&gt;</h4></section></summary><div class="docblock"><p>Read an event that borrows from the input rather than a buffer.</p>
<p>There is no asynchronous <code>read_event_async()</code> version of this function,
because it is not necessary – the contents are already in memory and no IO
is needed, therefore there is no potential for blocking.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quick_xml::events::Event;
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_str(<span class="string">r#&quot;
    &lt;tag1 att1 = &quot;test&quot;&gt;
       &lt;tag2&gt;&lt;!--Test comment--&gt;Test&lt;/tag2&gt;
       &lt;tag2&gt;Test 2&lt;/tag2&gt;
    &lt;/tag1&gt;
&quot;#</span>);
reader.trim_text(<span class="bool-val">true</span>);

<span class="kw">let </span><span class="kw-2">mut </span>count = <span class="number">0</span>;
<span class="kw">let </span><span class="kw-2">mut </span>txt = Vec::new();
<span class="kw">loop </span>{
    <span class="kw">match </span>reader.read_event().unwrap() {
        Event::Start(e) =&gt; count += <span class="number">1</span>,
        Event::Text(e) =&gt; txt.push(e.unescape().unwrap().into_owned()),
        Event::Eof =&gt; <span class="kw">break</span>,
        <span class="kw">_ </span>=&gt; (),
    }
}
<span class="macro">assert_eq!</span>(count, <span class="number">3</span>);
<span class="macro">assert_eq!</span>(txt, <span class="macro">vec!</span>[<span class="string">&quot;Test&quot;</span>.to_string(), <span class="string">&quot;Test 2&quot;</span>.to_string()]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_to_end" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/slice_reader.rs.html#157-159">source</a><h4 class="code-header">pub fn <a href="#method.read_to_end" class="fn">read_to_end</a>(&amp;mut self, end: <a class="struct" href="../name/struct.QName.html" title="struct quick_xml::name::QName">QName</a>&lt;'_&gt;) -&gt; <a class="type" href="../type.Result.html" title="type quick_xml::Result">Result</a>&lt;<a class="type" href="type.Span.html" title="type quick_xml::reader::Span">Span</a>&gt;</h4></section></summary><div class="docblock"><p>Reads until end element is found. This function is supposed to be called
after you already read a <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event.</p>
<p>Returns a span that cover content between <code>&gt;</code> of an opening tag and <code>&lt;</code> of
a closing tag or an empty slice, if <a href="struct.Reader.html#method.expand_empty_elements" title="method quick_xml::reader::Reader::expand_empty_elements"><code>expand_empty_elements</code></a> is set and
this method was called after reading expanded <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event.</p>
<p>Manages nested cases where parent and child elements have the <em>literally</em>
same name.</p>
<p>If corresponding <a href="../events/enum.Event.html#variant.End" title="variant quick_xml::events::Event::End"><code>End</code></a> event will not be found, the <a href="../enum.Error.html#variant.UnexpectedEof" title="variant quick_xml::Error::UnexpectedEof"><code>Error::UnexpectedEof</code></a>
will be returned. In particularly, that error will be returned if you call
this method without consuming the corresponding <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event first.</p>
<p>The <code>end</code> parameter should contain name of the end element <em>in the reader
encoding</em>. It is good practice to always get that parameter using
<a href="../events/struct.BytesStart.html#method.to_end" title="method quick_xml::events::BytesStart::to_end"><code>BytesStart::to_end()</code></a> method.</p>
<p>The correctness of the skipped events does not checked, if you disabled
the <a href="struct.Reader.html#method.check_end_names" title="method quick_xml::reader::Reader::check_end_names"><code>check_end_names</code></a> option.</p>
<p>There is no asynchronous <code>read_to_end_async()</code> version of this function,
because it is not necessary – the contents are already in memory and no IO
is needed, therefore there is no potential for blocking.</p>
<h5 id="namespaces-1"><a href="#namespaces-1">Namespaces</a></h5>
<p>While the <code>Reader</code> does not support namespace resolution, namespaces
does not change the algorithm for comparing names. Although the names
<code>a:name</code> and <code>b:name</code> where both prefixes <code>a</code> and <code>b</code> resolves to the
same namespace, are semantically equivalent, <code>&lt;/b:name&gt;</code> cannot close
<code>&lt;a:name&gt;</code>, because according to <a href="https://www.w3.org/TR/xml11/#dt-etag">the specification</a></p>
<blockquote>
<p>The end of every element that begins with a <strong>start-tag</strong> MUST be marked
by an <strong>end-tag</strong> containing a name that echoes the element’s type as
given in the <strong>start-tag</strong></p>
</blockquote>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<p>This example shows, how you can skip XML content after you read the
start event.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quick_xml::events::{BytesStart, Event};
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_str(<span class="string">r#&quot;
    &lt;outer&gt;
        &lt;inner&gt;
            &lt;inner&gt;&lt;/inner&gt;
            &lt;inner/&gt;
            &lt;outer&gt;&lt;/outer&gt;
            &lt;outer/&gt;
        &lt;/inner&gt;
    &lt;/outer&gt;
&quot;#</span>);
reader.trim_text(<span class="bool-val">true</span>);

<span class="kw">let </span>start = BytesStart::new(<span class="string">&quot;outer&quot;</span>);
<span class="kw">let </span>end   = start.to_end().into_owned();

<span class="comment">// First, we read a start event...
</span><span class="macro">assert_eq!</span>(reader.read_event().unwrap(), Event::Start(start));

<span class="comment">// ...then, we could skip all events to the corresponding end event.
// This call will correctly handle nested &lt;outer&gt; elements.
// Note, however, that this method does not handle namespaces.
</span>reader.read_to_end(end.name()).unwrap();

<span class="comment">// At the end we should get an Eof event, because we ate the whole XML
</span><span class="macro">assert_eq!</span>(reader.read_event().unwrap(), Event::Eof);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_text" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/slice_reader.rs.html#227-233">source</a><h4 class="code-header">pub fn <a href="#method.read_text" class="fn">read_text</a>(&amp;mut self, end: <a class="struct" href="../name/struct.QName.html" title="struct quick_xml::name::QName">QName</a>&lt;'_&gt;) -&gt; <a class="type" href="../type.Result.html" title="type quick_xml::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.71.1/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.str.html">str</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Reads content between start and end tags, including any markup. This
function is supposed to be called after you already read a <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event.</p>
<p>Manages nested cases where parent and child elements have the <em>literally</em>
same name.</p>
<p>This method does not unescape read data, instead it returns content
“as is” of the XML document. This is because it has no idea what text
it reads, and if, for example, it contains CDATA section, attempt to
unescape it content will spoil data.</p>
<p>Any text will be decoded using the XML current <a href="struct.Reader.html#method.decoder" title="method quick_xml::reader::Reader::decoder"><code>decoder()</code></a>.</p>
<p>Actually, this method perform the following code:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>span = reader.read_to_end(end)<span class="question-mark">?</span>;
<span class="kw">let </span>text = reader.decoder().decode(<span class="kw-2">&amp;</span>reader.inner_slice[span]);</code></pre></div>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<p>This example shows, how you can read a HTML content from your XML document.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quick_xml::events::{BytesStart, Event};
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_str(<span class="string">&quot;
    &lt;html&gt;
        &lt;title&gt;This is a HTML text&lt;/title&gt;
        &lt;p&gt;Usual XML rules does not apply inside it
        &lt;p&gt;For example, elements not needed to be &amp;quot;closed&amp;quot;
    &lt;/html&gt;
&quot;</span>);
reader.trim_text(<span class="bool-val">true</span>);

<span class="kw">let </span>start = BytesStart::new(<span class="string">&quot;html&quot;</span>);
<span class="kw">let </span>end   = start.to_end().into_owned();

<span class="comment">// First, we read a start event...
</span><span class="macro">assert_eq!</span>(reader.read_event().unwrap(), Event::Start(start));
<span class="comment">// ...and disable checking of end names because we expect HTML further...
</span>reader.check_end_names(<span class="bool-val">false</span>);

<span class="comment">// ...then, we could read text content until close tag.
// This call will correctly handle nested &lt;html&gt; elements.
</span><span class="kw">let </span>text = reader.read_text(end.name()).unwrap();
<span class="macro">assert_eq!</span>(text, Cow::Borrowed(<span class="string">r#&quot;
        &lt;title&gt;This is a HTML text&lt;/title&gt;
        &lt;p&gt;Usual XML rules does not apply inside it
        &lt;p&gt;For example, elements not needed to be &amp;quot;closed&amp;quot;
    &quot;#</span>));
<span class="macro">assert!</span>(<span class="macro">matches!</span>(text, Cow::Borrowed(<span class="kw">_</span>)));

<span class="comment">// Now we can enable checks again
</span>reader.check_end_names(<span class="bool-val">true</span>);

<span class="comment">// At the end we should get an Eof event, because we ate the whole XML
</span><span class="macro">assert_eq!</span>(reader.read_event().unwrap(), Event::Eof);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Reader%3CR%3E-1" class="impl"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#531-541">source</a><a href="#impl-Reader%3CR%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;</h3></section></summary><div class="docblock"><p>Builder methods</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_reader" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#533-538">source</a><h4 class="code-header">pub fn <a href="#method.from_reader" class="fn">from_reader</a>(reader: R) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a <code>Reader</code> that reads from a given reader.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.expand_empty_elements" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#540">source</a><h4 class="code-header">pub fn <a href="#method.expand_empty_elements" class="fn">expand_empty_elements</a>(&amp;mut self, val: <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;mut Self</a></h4></section></summary><div class="docblock"><p>Changes whether empty elements should be split into an <code>Open</code> and a <code>Close</code> event.</p>
<p>When set to <code>true</code>, all <a href="../events/enum.Event.html#variant.Empty" title="variant quick_xml::events::Event::Empty"><code>Empty</code></a> events produced by a self-closing tag like <code>&lt;tag/&gt;</code> are
expanded into a <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event followed by an <a href="../events/enum.Event.html#variant.End" title="variant quick_xml::events::Event::End"><code>End</code></a> event. When set to <code>false</code> (the
default), those tags are represented by an <a href="../events/enum.Event.html#variant.Empty" title="variant quick_xml::events::Event::Empty"><code>Empty</code></a> event instead.</p>
<p>Note, that setting this to <code>true</code> will lead to additional allocates that
needed to store tag name for an <a href="../events/enum.Event.html#variant.End" title="variant quick_xml::events::Event::End"><code>End</code></a> event. However if <a href="struct.Reader.html#method.check_end_names" title="method quick_xml::reader::Reader::check_end_names"><code>check_end_names</code></a>
is also set, only one additional allocation will be performed that support
both these options.</p>
<p>(<code>false</code> by default)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_text" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#540">source</a><h4 class="code-header">pub fn <a href="#method.trim_text" class="fn">trim_text</a>(&amp;mut self, val: <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;mut Self</a></h4></section></summary><div class="docblock"><p>Changes whether whitespace before and after character data should be removed.</p>
<p>When set to <code>true</code>, all <a href="../events/enum.Event.html#variant.Text" title="variant quick_xml::events::Event::Text"><code>Text</code></a> events are trimmed.
If after that the event is empty it will not be pushed.</p>
<p>Changing this option automatically changes the <a href="struct.Reader.html#method.trim_text_end" title="method quick_xml::reader::Reader::trim_text_end"><code>trim_text_end</code></a> option.</p>
<p>(<code>false</code> by default).</p>
<div style="background:rgba(80, 240, 100, 0.20);padding:0.75em;">
<p>WARNING: With this option every text events will be trimmed which is
incorrect behavior when text events delimited by comments, processing
instructions or CDATA sections. To correctly trim data manually apply
<a href="../events/struct.BytesText.html#method.inplace_trim_start" title="method quick_xml::events::BytesText::inplace_trim_start"><code>BytesText::inplace_trim_start</code></a> and <a href="../events/struct.BytesText.html#method.inplace_trim_end" title="method quick_xml::events::BytesText::inplace_trim_end"><code>BytesText::inplace_trim_end</code></a>
only to necessary events.</p>
</div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_text_end" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#540">source</a><h4 class="code-header">pub fn <a href="#method.trim_text_end" class="fn">trim_text_end</a>(&amp;mut self, val: <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;mut Self</a></h4></section></summary><div class="docblock"><p>Changes whether whitespace after character data should be removed.</p>
<p>When set to <code>true</code>, trailing whitespace is trimmed in <a href="../events/enum.Event.html#variant.Text" title="variant quick_xml::events::Event::Text"><code>Text</code></a> events.
If after that the event is empty it will not be pushed.</p>
<p>(<code>false</code> by default).</p>
<div style="background:rgba(80, 240, 100, 0.20);padding:0.75em;">
<p>WARNING: With this option every text events will be trimmed which is
incorrect behavior when text events delimited by comments, processing
instructions or CDATA sections. To correctly trim data manually apply
<a href="../events/struct.BytesText.html#method.inplace_trim_start" title="method quick_xml::events::BytesText::inplace_trim_start"><code>BytesText::inplace_trim_start</code></a> and <a href="../events/struct.BytesText.html#method.inplace_trim_end" title="method quick_xml::events::BytesText::inplace_trim_end"><code>BytesText::inplace_trim_end</code></a>
only to necessary events.</p>
</div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_markup_names_in_closing_tags" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#540">source</a><h4 class="code-header">pub fn <a href="#method.trim_markup_names_in_closing_tags" class="fn">trim_markup_names_in_closing_tags</a>(&amp;mut self, val: <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;mut Self</a></h4></section></summary><div class="docblock"><p>Changes whether trailing whitespaces after the markup name are trimmed in closing tags
<code>&lt;/a &gt;</code>.</p>
<p>If true the emitted <a href="../events/enum.Event.html#variant.End" title="variant quick_xml::events::Event::End"><code>End</code></a> event is stripped of trailing whitespace after the markup name.</p>
<p>Note that if set to <code>false</code> and <code>check_end_names</code> is true the comparison of markup names is
going to fail erroneously if a closing tag contains trailing whitespaces.</p>
<p>(<code>true</code> by default)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.check_end_names" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#540">source</a><h4 class="code-header">pub fn <a href="#method.check_end_names" class="fn">check_end_names</a>(&amp;mut self, val: <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;mut Self</a></h4></section></summary><div class="docblock"><p>Changes whether mismatched closing tag names should be detected.</p>
<p>Note, that start and end tags <a href="https://www.w3.org/TR/xml11/#dt-etag">should match literally</a>, they cannot
have different prefixes even if both prefixes resolve to the same namespace.
The XML</p>
<div class="example-wrap"><pre class="language-xml"><code>&lt;outer xmlns=&quot;namespace&quot; xmlns:p=&quot;namespace&quot;&gt;
&lt;/p:outer&gt;
</code></pre></div>
<p>is not valid, even though semantically the start tag is the same as the
end tag. The reason is that namespaces are an extension of the original
XML specification (without namespaces) and it should be backward-compatible.</p>
<p>When set to <code>false</code>, it won’t check if a closing tag matches the corresponding opening tag.
For example, <code>&lt;mytag&gt;&lt;/different_tag&gt;</code> will be permitted.</p>
<p>If the XML is known to be sane (already processed, etc.) this saves extra time.</p>
<p>Note that the emitted <a href="../events/enum.Event.html#variant.End" title="variant quick_xml::events::Event::End"><code>End</code></a> event will not be modified if this is disabled, ie. it will
contain the data of the mismatched end tag.</p>
<p>Note, that setting this to <code>true</code> will lead to additional allocates that
needed to store tag name for an <a href="../events/enum.Event.html#variant.End" title="variant quick_xml::events::Event::End"><code>End</code></a> event. However if <a href="struct.Reader.html#method.expand_empty_elements" title="method quick_xml::reader::Reader::expand_empty_elements"><code>expand_empty_elements</code></a>
is also set, only one additional allocation will be performed that support
both these options.</p>
<p>(<code>true</code> by default)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.check_comments" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#540">source</a><h4 class="code-header">pub fn <a href="#method.check_comments" class="fn">check_comments</a>(&amp;mut self, val: <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;mut Self</a></h4></section></summary><div class="docblock"><p>Changes whether comments should be validated.</p>
<p>When set to <code>true</code>, every <a href="../events/enum.Event.html#variant.Comment" title="variant quick_xml::events::Event::Comment"><code>Comment</code></a> event will be checked for not containing <code>--</code>, which
is not allowed in XML comments. Most of the time we don’t want comments at all so we don’t
really care about comment correctness, thus the default value is <code>false</code> to improve
performance.</p>
<p>(<code>false</code> by default)</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Reader%3CR%3E-2" class="impl"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#544-636">source</a><a href="#impl-Reader%3CR%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;</h3></section></summary><div class="docblock"><p>Getters</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_inner" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#598-600">source</a><h4 class="code-header">pub fn <a href="#method.into_inner" class="fn">into_inner</a>(self) -&gt; R</h4></section></summary><div class="docblock"><p>Consumes <code>Reader</code> returning the underlying reader</p>
<p>Can be used to compute line and column of a parsing error position</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{str, io::Cursor};
<span class="kw">use </span>quick_xml::events::Event;
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span>xml = <span class="string">r#&quot;&lt;tag1 att1 = &quot;test&quot;&gt;
                &lt;tag2&gt;&lt;!--Test comment--&gt;Test&lt;/tag2&gt;
                &lt;tag3&gt;Test 2&lt;/tag3&gt;
             &lt;/tag1&gt;&quot;#</span>;
<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_reader(Cursor::new(xml.as_bytes()));
<span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();

<span class="kw">fn </span>into_line_and_column(reader: Reader&lt;Cursor&lt;<span class="kw-2">&amp;</span>[u8]&gt;&gt;) -&gt; (usize, usize) {
    <span class="kw">let </span>end_pos = reader.buffer_position();
    <span class="kw">let </span><span class="kw-2">mut </span>cursor = reader.into_inner();
    <span class="kw">let </span>s = String::from_utf8(cursor.into_inner()[<span class="number">0</span>..end_pos].to_owned())
        .expect(<span class="string">&quot;can&#39;t make a string&quot;</span>);
    <span class="kw">let </span><span class="kw-2">mut </span>line = <span class="number">1</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>column = <span class="number">0</span>;
    <span class="kw">for </span>c <span class="kw">in </span>s.chars() {
        <span class="kw">if </span>c == <span class="string">&#39;\n&#39; </span>{
            line += <span class="number">1</span>;
            column = <span class="number">0</span>;
        } <span class="kw">else </span>{
            column += <span class="number">1</span>;
        }
    }
    (line, column)
}

<span class="kw">loop </span>{
    <span class="kw">match </span>reader.read_event_into(<span class="kw-2">&amp;mut </span>buf) {
        <span class="prelude-val">Ok</span>(Event::Start(<span class="kw-2">ref </span>e)) =&gt; <span class="kw">match </span>e.name().as_ref() {
            <span class="string">b&quot;tag1&quot; </span>| <span class="string">b&quot;tag2&quot; </span>=&gt; (),
            tag =&gt; {
                <span class="macro">assert_eq!</span>(<span class="string">b&quot;tag3&quot;</span>, tag);
                <span class="macro">assert_eq!</span>((<span class="number">3</span>, <span class="number">22</span>), into_line_and_column(reader));
                <span class="kw">break</span>;
            }
        },
        <span class="prelude-val">Ok</span>(Event::Eof) =&gt; <span class="macro">unreachable!</span>(),
        <span class="kw">_ </span>=&gt; (),
    }
    buf.clear();
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_ref" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#603-605">source</a><h4 class="code-header">pub fn <a href="#method.get_ref" class="fn">get_ref</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;R</a></h4></section></summary><div class="docblock"><p>Gets a reference to the underlying reader.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#608-610">source</a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fn">get_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;mut R</a></h4></section></summary><div class="docblock"><p>Gets a mutable reference to the underlying reader.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.buffer_position" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#615-623">source</a><h4 class="code-header">pub fn <a href="#method.buffer_position" class="fn">buffer_position</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Gets the current byte position in the input data.</p>
<p>Useful when debugging errors.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.decoder" class="method"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#633-635">source</a><h4 class="code-header">pub fn <a href="#method.decoder" class="fn">decoder</a>(&amp;self) -&gt; <a class="struct" href="../encoding/struct.Decoder.html" title="struct quick_xml::encoding::Decoder">Decoder</a></h4></section></summary><div class="docblock"><p>Get the decoder, used to decode bytes, read by this reader, to the strings.</p>
<p>If <code>encoding</code> feature is enabled, the used encoding may change after
parsing the XML declaration, otherwise encoding is fixed to UTF-8.</p>
<p>If <code>encoding</code> feature is enabled and no encoding is specified in declaration,
defaults to UTF-8.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Reader%3CR%3E" class="impl"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#522">source</a><a href="#impl-Clone-for-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R: <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="srclink rightside" href="../../src/quick_xml/reader/mod.rs.html#522">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.71.1/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.71.1/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.71.1/src/core/clone.rs.html#129">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.71.1/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.71.1/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Reader%3CR%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;<span class="where fmt-newline">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section><section id="impl-Send-for-Reader%3CR%3E" class="impl"><a href="#impl-Send-for-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;<span class="where fmt-newline">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</span></h3></section><section id="impl-Sync-for-Reader%3CR%3E" class="impl"><a href="#impl-Sync-for-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;<span class="where fmt-newline">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</span></h3></section><section id="impl-Unpin-for-Reader%3CR%3E" class="impl"><a href="#impl-Unpin-for-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;<span class="where fmt-newline">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</span></h3></section><section id="impl-UnwindSafe-for-Reader%3CR%3E" class="impl"><a href="#impl-UnwindSafe-for-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;<span class="where fmt-newline">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-Reader%3CR%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.71.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.71.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.71.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.71.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-Reader%3CR%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.71.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.71.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.71.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-Reader%3CR%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.71.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.71.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.71.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-Reader%3CR%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/core/convert/mod.rs.html#723">source</a><a href="#impl-From%3CT%3E-for-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/core/convert/mod.rs.html#726">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.71.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-Reader%3CR%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/core/convert/mod.rs.html#707">source</a><a href="#impl-Into%3CU%3E-for-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/core/convert/mod.rs.html#716">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.71.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.71.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-Reader%3CR%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/alloc/borrow.rs.html#82">source</a><a href="#impl-ToOwned-for-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.71.1/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.71.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/alloc/borrow.rs.html#87">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.71.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.71.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/alloc/borrow.rs.html#91">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.71.1/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.71.1/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-Reader%3CR%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/core/convert/mod.rs.html#763">source</a><a href="#impl-TryFrom%3CU%3E-for-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.71.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.71.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/core/convert/mod.rs.html#770">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.71.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.71.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.71.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-Reader%3CR%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/core/convert/mod.rs.html#748">source</a><a href="#impl-TryInto%3CU%3E-for-Reader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.71.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.71.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.71.1/src/core/convert/mod.rs.html#755">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.71.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.71.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.71.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>