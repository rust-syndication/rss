<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Zero-copy vector abstractions for arbitrary types, backed by byte slices."><title>zerovec - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="zerovec" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../zerovec/index.html">zerovec</a><span class="version">0.10.4</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#attributes">Attribute Macros</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">zerovec</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/zerovec/lib.rs.html#5-558">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Zero-copy vector abstractions for arbitrary types, backed by byte slices.</p>
<p><code>zerovec</code> enables a far wider range of types — beyond just <code>&amp;[u8]</code> and <code>&amp;str</code> — to participate in
zero-copy deserialization from byte slices. It is <code>serde</code> compatible and comes equipped with
proc macros</p>
<p>Clients upgrading to <code>zerovec</code> benefit from zero heap allocations when deserializing
read-only data.</p>
<p>This crate has four main types:</p>
<ul>
<li><a href="struct.ZeroVec.html" title="struct zerovec::ZeroVec"><code>ZeroVec&lt;'a, T&gt;</code></a> (and <a href="struct.ZeroSlice.html" title="struct zerovec::ZeroSlice"><code>ZeroSlice&lt;T&gt;</code></a>) for fixed-width types like <code>u32</code></li>
<li><a href="enum.VarZeroVec.html" title="enum zerovec::VarZeroVec"><code>VarZeroVec&lt;'a, T&gt;</code></a> (and <a href="struct.ZeroSlice.html" title="struct zerovec::ZeroSlice"><code>VarZeroSlice&lt;T&gt;</code></a>) for variable-width types like <code>str</code></li>
<li><a href="struct.ZeroMap.html" title="struct zerovec::ZeroMap"><code>ZeroMap&lt;'a, K, V&gt;</code></a> to map from <code>K</code> to <code>V</code></li>
<li><a href="struct.ZeroMap2d.html" title="struct zerovec::ZeroMap2d"><code>ZeroMap2d&lt;'a, K0, K1, V&gt;</code></a> to map from the pair <code>(K0, K1)</code> to <code>V</code></li>
</ul>
<p>The first two are intended as close-to-drop-in replacements for <code>Vec&lt;T&gt;</code> in Serde structs. The third and fourth are
intended as a replacement for <code>HashMap</code> or <a href="docs.rs/litemap"><code>LiteMap</code></a>. When used with Serde derives, <strong>be sure to apply
<code>#[serde(borrow)]</code> to these types</strong>, same as one would for <a href="https://doc.rust-lang.org/1.82.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow"><code>Cow&lt;'a, T&gt;</code></a>.</p>
<p><a href="struct.ZeroVec.html" title="struct zerovec::ZeroVec"><code>ZeroVec&lt;'a, T&gt;</code></a>, <a href="enum.VarZeroVec.html" title="enum zerovec::VarZeroVec"><code>VarZeroVec&lt;'a, T&gt;</code></a>, <a href="struct.ZeroMap.html" title="struct zerovec::ZeroMap"><code>ZeroMap&lt;'a, K, V&gt;</code></a>, and <a href="struct.ZeroMap2d.html" title="struct zerovec::ZeroMap2d"><code>ZeroMap2d&lt;'a, K0, K1, V&gt;</code></a> all behave like
<a href="https://doc.rust-lang.org/1.82.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow"><code>Cow&lt;'a, T&gt;</code></a> in that they abstract over either borrowed or owned data. When performing deserialization
from human-readable formats (like <code>json</code> and <code>xml</code>), typically these types will allocate and fully own their data, whereas if deserializing
from binary formats like <code>bincode</code> and <code>postcard</code>, these types will borrow data directly from the buffer being deserialized from,
avoiding allocations and only performing validity checks. As such, this crate can be pretty fast (see <a href="#Performance">below</a> for more information)
on deserialization.</p>
<p>See <a href="https://github.com/unicode-org/icu4x/blob/main/utils/zerovec/design_doc.md">the design doc</a> for details on how this crate
works under the hood.</p>
<h2 id="cargo-features"><a class="doc-anchor" href="#cargo-features">§</a>Cargo features</h2>
<p>This crate has several optional Cargo features:</p>
<ul>
<li><code>serde</code>: Allows serializing and deserializing <code>zerovec</code>’s abstractions via <a href="https://docs.rs/serde"><code>serde</code></a></li>
<li><code>yoke</code>: Enables implementations of <code>Yokeable</code> from the <a href="https://docs.rs/yoke/"><code>yoke</code></a> crate, which is also useful
in situations involving a lot of zero-copy deserialization.</li>
<li><code>derive</code>: Makes it easier to use custom types in these collections by providing the <a href="attr.make_ule.html" title="attr zerovec::make_ule"><code>#[make_ule]</code></a> and
<a href="attr.make_varule.html" title="attr zerovec::make_varule"><code>#[make_varule]</code></a> proc macros, which generate appropriate <a href="ule/trait.ULE.html" title="trait zerovec::ule::ULE"><code>ULE</code></a> and
<a href="ule/trait.VarULE.html" title="trait zerovec::ule::VarULE"><code>VarULE</code></a>-conformant types for a given “normal” type.</li>
<li><code>std</code>: Enabled <code>std::Error</code> implementations for error types. This crate is by default <code>no_std</code> with a dependency on <code>alloc</code>.</li>
</ul>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>Serialize and deserialize a struct with ZeroVec and VarZeroVec with Bincode:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zerovec::{VarZeroVec, ZeroVec};

<span class="comment">// This example requires the "serde" feature
</span><span class="attr">#[derive(serde::Serialize, serde::Deserialize)]
</span><span class="kw">pub struct </span>DataStruct&lt;<span class="lifetime">'data</span>&gt; {
    <span class="attr">#[serde(borrow)]
    </span>nums: ZeroVec&lt;<span class="lifetime">'data</span>, u32&gt;,
    <span class="attr">#[serde(borrow)]
    </span>chars: ZeroVec&lt;<span class="lifetime">'data</span>, char&gt;,
    <span class="attr">#[serde(borrow)]
    </span>strs: VarZeroVec&lt;<span class="lifetime">'data</span>, str&gt;,
}

<span class="kw">let </span>data = DataStruct {
    nums: ZeroVec::from_slice_or_alloc(<span class="kw-2">&amp;</span>[<span class="number">211</span>, <span class="number">281</span>, <span class="number">421</span>, <span class="number">461</span>]),
    chars: ZeroVec::alloc_from_slice(<span class="kw-2">&amp;</span>[<span class="string">'ö'</span>, <span class="string">'冇'</span>, <span class="string">'म'</span>]),
    strs: VarZeroVec::from(<span class="kw-2">&amp;</span>[<span class="string">"hello"</span>, <span class="string">"world"</span>]),
};
<span class="kw">let </span>bincode_bytes =
    bincode::serialize(<span class="kw-2">&amp;</span>data).expect(<span class="string">"Serialization should be successful"</span>);
<span class="macro">assert_eq!</span>(bincode_bytes.len(), <span class="number">67</span>);

<span class="kw">let </span>deserialized: DataStruct = bincode::deserialize(<span class="kw-2">&amp;</span>bincode_bytes)
    .expect(<span class="string">"Deserialization should be successful"</span>);
<span class="macro">assert_eq!</span>(deserialized.nums.first(), <span class="prelude-val">Some</span>(<span class="number">211</span>));
<span class="macro">assert_eq!</span>(deserialized.chars.get(<span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="string">'冇'</span>));
<span class="macro">assert_eq!</span>(deserialized.strs.get(<span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="string">"world"</span>));
<span class="comment">// The deserialization will not have allocated anything
</span><span class="macro">assert!</span>(!deserialized.nums.is_owned());</code></pre></div>
<p>Use custom types inside of ZeroVec:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zerovec::{ZeroVec, VarZeroVec, ZeroMap};
<span class="kw">use </span>std::borrow::Cow;
<span class="kw">use </span>zerovec::ule::encode_varule_to_box;

<span class="comment">// custom fixed-size ULE type for ZeroVec
</span><span class="attr">#[zerovec::make_ule(DateULE)]
#[derive(Copy, Clone, PartialEq, Eq, Ord, PartialOrd, serde::Serialize, serde::Deserialize)]
</span><span class="kw">struct </span>Date {
    y: u64,
    m: u8,
    d: u8
}

<span class="comment">// custom variable sized VarULE type for VarZeroVec
</span><span class="attr">#[zerovec::make_varule(PersonULE)]
#[zerovec::derive(Serialize, Deserialize)] </span><span class="comment">// add Serde impls to PersonULE
</span><span class="attr">#[derive(Clone, PartialEq, Eq, Ord, PartialOrd, serde::Serialize, serde::Deserialize)]
</span><span class="kw">struct </span>Person&lt;<span class="lifetime">'a</span>&gt; {
    birthday: Date,
    favorite_character: char,
    <span class="attr">#[serde(borrow)]
    </span>name: Cow&lt;<span class="lifetime">'a</span>, str&gt;,
}

<span class="attr">#[derive(serde::Serialize, serde::Deserialize)]
</span><span class="kw">struct </span>Data&lt;<span class="lifetime">'a</span>&gt; {
    <span class="attr">#[serde(borrow)]
    </span>important_dates: ZeroVec&lt;<span class="lifetime">'a</span>, Date&gt;,
    <span class="comment">// note: VarZeroVec always must reference the ULE type directly
    </span><span class="attr">#[serde(borrow)]
    </span>important_people: VarZeroVec&lt;<span class="lifetime">'a</span>, PersonULE&gt;,
    <span class="attr">#[serde(borrow)]
    </span>birthdays_to_people: ZeroMap&lt;<span class="lifetime">'a</span>, Date, PersonULE&gt;
}


<span class="kw">let </span>person1 = Person {
    birthday: Date { y: <span class="number">1990</span>, m: <span class="number">9</span>, d: <span class="number">7</span>},
    favorite_character: <span class="string">'π'</span>,
    name: Cow::from(<span class="string">"Kate"</span>)
};
<span class="kw">let </span>person2 = Person {
    birthday: Date { y: <span class="number">1960</span>, m: <span class="number">5</span>, d: <span class="number">25</span>},
    favorite_character: <span class="string">'冇'</span>,
    name: Cow::from(<span class="string">"Jesse"</span>)
};

<span class="kw">let </span>important_dates = ZeroVec::alloc_from_slice(<span class="kw-2">&amp;</span>[Date { y: <span class="number">1943</span>, m: <span class="number">3</span>, d: <span class="number">20</span>}, Date { y: <span class="number">1976</span>, m: <span class="number">8</span>, d: <span class="number">2</span>}, Date { y: <span class="number">1998</span>, m: <span class="number">2</span>, d: <span class="number">15</span>}]);
<span class="kw">let </span>important_people = VarZeroVec::from(<span class="kw-2">&amp;</span>[<span class="kw-2">&amp;</span>person1, <span class="kw-2">&amp;</span>person2]);
<span class="kw">let </span><span class="kw-2">mut </span>birthdays_to_people: ZeroMap&lt;Date, PersonULE&gt; = ZeroMap::new();
<span class="comment">// `.insert_var_v()` is slightly more convenient over `.insert()` for custom ULE types
</span>birthdays_to_people.insert_var_v(<span class="kw-2">&amp;</span>person1.birthday, <span class="kw-2">&amp;</span>person1);
birthdays_to_people.insert_var_v(<span class="kw-2">&amp;</span>person2.birthday, <span class="kw-2">&amp;</span>person2);

<span class="kw">let </span>data = Data { important_dates, important_people, birthdays_to_people };

<span class="kw">let </span>bincode_bytes = bincode::serialize(<span class="kw-2">&amp;</span>data)
    .expect(<span class="string">"Serialization should be successful"</span>);
<span class="macro">assert_eq!</span>(bincode_bytes.len(), <span class="number">168</span>);

<span class="kw">let </span>deserialized: Data = bincode::deserialize(<span class="kw-2">&amp;</span>bincode_bytes)
    .expect(<span class="string">"Deserialization should be successful"</span>);

<span class="macro">assert_eq!</span>(deserialized.important_dates.get(<span class="number">0</span>).unwrap().y, <span class="number">1943</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>deserialized.important_people.get(<span class="number">1</span>).unwrap().name, <span class="string">"Jesse"</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>deserialized.important_people.get(<span class="number">0</span>).unwrap().name, <span class="string">"Kate"</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>deserialized.birthdays_to_people.get(<span class="kw-2">&amp;</span>person1.birthday).unwrap().name, <span class="string">"Kate"</span>);

} <span class="comment">// feature = serde and derive</span></code></pre></div>
<h2 id="performance"><a class="doc-anchor" href="#performance">§</a>Performance</h2>
<p><code>zerovec</code> is designed for fast deserialization from byte buffers with zero memory allocations
while minimizing performance regressions for common vector operations.</p>
<p>Benchmark results on x86_64:</p>
<div><table><thead><tr><th>Operation</th><th><code>Vec&lt;T&gt;</code></th><th><code>zerovec</code></th></tr></thead><tbody>
<tr><td>Deserialize vec of 100 <code>u32</code></td><td>233.18 ns</td><td>14.120 ns</td></tr>
<tr><td>Compute sum of vec of 100 <code>u32</code> (read every element)</td><td>8.7472 ns</td><td>10.775 ns</td></tr>
<tr><td>Binary search vec of 1000 <code>u32</code> 50 times</td><td>442.80 ns</td><td>472.51 ns</td></tr>
<tr><td>Deserialize vec of 100 strings</td><td>7.3740 μs*</td><td>1.4495 μs</td></tr>
<tr><td>Count chars in vec of 100 strings (read every element)</td><td>747.50 ns</td><td>955.28 ns</td></tr>
<tr><td>Binary search vec of 500 strings 10 times</td><td>466.09 ns</td><td>790.33 ns</td></tr>
</tbody></table>
</div>
<p>* <em>This result is reported for <code>Vec&lt;String&gt;</code>. However, Serde also supports deserializing to the partially-zero-copy <code>Vec&lt;&amp;str&gt;</code>; this gives 1.8420 μs, much faster than <code>Vec&lt;String&gt;</code> but a bit slower than <code>zerovec</code>.</em></p>
<div><table><thead><tr><th>Operation</th><th><code>HashMap&lt;K,V&gt;</code></th><th><code>LiteMap&lt;K,V&gt;</code></th><th><code>ZeroMap&lt;K,V&gt;</code></th></tr></thead><tbody>
<tr><td>Deserialize a small map</td><td>2.72 μs</td><td>1.28 μs</td><td>480 ns</td></tr>
<tr><td>Deserialize a large map</td><td>50.5 ms</td><td>18.3 ms</td><td>3.74 ms</td></tr>
<tr><td>Look up from a small deserialized map</td><td>49 ns</td><td>42 ns</td><td>54 ns</td></tr>
<tr><td>Look up from a large deserialized map</td><td>51 ns</td><td>155 ns</td><td>213 ns</td></tr>
</tbody></table>
</div>
<p>Small = 16 elements, large = 131,072 elements. Maps contain <code>&lt;String, String&gt;</code>.</p>
<p>The benches used to generate the above table can be found in the <code>benches</code> directory in the project repository.
<code>zeromap</code> benches are named by convention, e.g. <code>zeromap/deserialize/small</code>, <code>zeromap/lookup/large</code>. The type
is appended for baseline comparisons, e.g. <code>zeromap/lookup/small/hashmap</code>.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="maps/index.html" title="mod zerovec::maps">maps</a></div><div class="desc docblock-short">This module contains additional utility types and traits for working with
<a href="struct.ZeroMap.html" title="struct zerovec::ZeroMap"><code>ZeroMap</code></a> and <a href="struct.ZeroMap2d.html" title="struct zerovec::ZeroMap2d"><code>ZeroMap2d</code></a>. See their docs for more details on the general purpose
of these types.</div></li><li><div class="item-name"><a class="mod" href="ule/index.html" title="mod zerovec::ule">ule</a></div><div class="desc docblock-short">Traits over unaligned little-endian data (ULE, pronounced “yule”).</div></li><li><div class="item-name"><a class="mod" href="vecs/index.html" title="mod zerovec::vecs">vecs</a></div><div class="desc docblock-short">This module contains additional utility types for working with
<a href="struct.ZeroVec.html" title="struct zerovec::ZeroVec"><code>ZeroVec</code></a> and  <a href="enum.VarZeroVec.html" title="enum zerovec::VarZeroVec"><code>VarZeroVec</code></a>. See their docs for more details on the general purpose
of these types.</div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.impl_ule_from_array.html" title="macro zerovec::impl_ule_from_array">impl_<wbr>ule_<wbr>from_<wbr>array</a></div><div class="desc docblock-short">Given <code>Self</code> (<code>$aligned</code>), <code>Self::ULE</code> (<code>$unaligned</code>), and a conversion function (<code>$single</code> or
<code>Self::from_aligned</code>), implement <code>from_array</code> for arrays of <code>$aligned</code> to <code>$unaligned</code>.</div></li><li><div class="item-name"><a class="macro" href="macro.zeroslice.html" title="macro zerovec::zeroslice">zeroslice</a></div><div class="desc docblock-short">Convenience wrapper for <a href="struct.ZeroSlice.html#method.from_ule_slice" title="associated function zerovec::ZeroSlice::from_ule_slice"><code>ZeroSlice::from_ule_slice</code></a>. The value will be created at compile-time,
meaning that all arguments must also be constant.</div></li><li><div class="item-name"><a class="macro" href="macro.zerovec.html" title="macro zerovec::zerovec">zerovec</a></div><div class="desc docblock-short">Creates a borrowed <code>ZeroVec</code>. Convenience wrapper for <code>zeroslice!(...).as_zerovec()</code>. The value
will be created at compile-time, meaning that all arguments must also be constant.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.VarZeroSlice.html" title="struct zerovec::VarZeroSlice">VarZero<wbr>Slice</a></div><div class="desc docblock-short">A zero-copy “slice”, that works for unsized types, i.e. the zero-copy version of <code>[T]</code>
where <code>T</code> is not <code>Sized</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ZeroMap.html" title="struct zerovec::ZeroMap">ZeroMap</a></div><div class="desc docblock-short">A zero-copy map datastructure, built on sorted binary-searchable <a href="struct.ZeroVec.html" title="struct zerovec::ZeroVec"><code>ZeroVec</code></a>
and <a href="enum.VarZeroVec.html" title="enum zerovec::VarZeroVec"><code>VarZeroVec</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.ZeroMap2d.html" title="struct zerovec::ZeroMap2d">Zero<wbr>Map2d</a></div><div class="desc docblock-short">A zero-copy, two-dimensional map datastructure .</div></li><li><div class="item-name"><a class="struct" href="struct.ZeroSlice.html" title="struct zerovec::ZeroSlice">Zero<wbr>Slice</a></div><div class="desc docblock-short">A zero-copy “slice”, i.e. the zero-copy version of <code>[T]</code>. This behaves
similarly to <a href="struct.ZeroVec.html" title="struct zerovec::ZeroVec"><code>ZeroVec&lt;T&gt;</code></a>, however <a href="struct.ZeroVec.html" title="struct zerovec::ZeroVec"><code>ZeroVec&lt;T&gt;</code></a> is allowed to contain
owned data and as such is ideal for deserialization since most human readable
serialization formats cannot unconditionally deserialize zero-copy.</div></li><li><div class="item-name"><a class="struct" href="struct.ZeroVec.html" title="struct zerovec::ZeroVec">ZeroVec</a></div><div class="desc docblock-short">A zero-copy, byte-aligned vector for fixed-width types.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.VarZeroVec.html" title="enum zerovec::VarZeroVec">VarZero<wbr>Vec</a></div><div class="desc docblock-short">A zero-copy, byte-aligned vector for variable-width types.</div></li><li><div class="item-name"><a class="enum" href="enum.ZeroVecError.html" title="enum zerovec::ZeroVecError">Zero<wbr>VecError</a></div><div class="desc docblock-short">A generic error type to be used for decoding slices of ULE types</div></li></ul><h2 id="attributes" class="section-header">Attribute Macros<a href="#attributes" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="attr" href="attr.make_ule.html" title="attr zerovec::make_ule">make_<wbr>ule</a></div><div class="desc docblock-short">Generate a corresponding <a href="ule/trait.ULE.html" title="trait zerovec::ule::ULE"><code>ULE</code></a> type and the relevant <a href="ule/trait.AsULE.html" title="trait zerovec::ule::AsULE"><code>AsULE</code></a> implementations for this type</div></li><li><div class="item-name"><a class="attr" href="attr.make_varule.html" title="attr zerovec::make_varule">make_<wbr>varule</a></div><div class="desc docblock-short">Generate a corresponding <a href="ule/trait.VarULE.html" title="trait zerovec::ule::VarULE"><code>VarULE</code></a> type and the relevant <a href="ule/trait.EncodeAsVarULE.html" title="trait zerovec::ule::EncodeAsVarULE"><code>EncodeAsVarULE</code></a>/<a href="../zerofrom/zero_from/trait.ZeroFrom.html" title="trait zerofrom::zero_from::ZeroFrom"><code>zerofrom::ZeroFrom</code></a>
implementations for this type</div></li></ul></section></div></main></body></html>